#pragma once

#include <stdexcept>

namespace Example1
{
    class IA
    {
    public:
        virtual ~IA() {}
        virtual void A() = 0;
    };


    class IB
    {
    public:
        virtual ~IB() {}
        virtual void B() = 0;
    };



    class Base
    {
    public:
        virtual ~Base() {}

        // Returns interface IA for this class if IA is supported.
        // Otherwise returns nullptr.
        virtual IA* GetAMethods()
        {
            return nullptr;
        }

        // Returns interface IB for this class if IB is supported.
        // Otherwise returns nullptr.
        virtual IB* GetBMethods()
        {
            return nullptr;
        }
    };


    class ImplementsA : public Base, public IA
    {
        virtual IA* GetAMethods() override
        {
            return this;
        }

        virtual void A() override
        {
            // Do operation A.
        }
    };


    class ImplementsB : public Base, public IB
    {
        virtual IB* GetBMethods() override
        {
            return this;
        }

        virtual void B() override
        {
            // Do operation B.
        }
    };


    void DoSomething(Base& object)
    {
        IA* a = object.GetAMethods();
        if (a != nullptr)
        {
            a->A();
        }
        else
        {
            IB* b = object.GetBMethods();

            if (b != nullptr)
            {
                b->B();
            }
            else
            {
                throw std::exception("Expected object to implement IA or IB");
            }
        }
    }
}


namespace Example2
{
    class IA
    {
    public:
        virtual ~IA() {}
        virtual void A() = 0;
    };


    class IB
    {
    public:
        virtual ~IB() {}
        virtual void B() = 0;
    };



    class Base
    {
    public:
        enum class ObjectType {IsA, IsB};

        Base(ObjectType objectType)
            : m_objectType(objectType)
        {
        }

        virtual ~Base() {}


        ObjectType GetType() const
        {
            return m_objectType;
        }

    private:
        ObjectType m_objectType;
    };


    class ImplementsA : public Base, public IA
    {
        ImplementsA()
            : Base(Base::ObjectType::IsA)
        {
        }

        virtual void A() override
        {
            // Do operation A.
        }
    };


    class ImplementsB : public Base, public IB
    {
        ImplementsB()
            : Base(Base::ObjectType::IsB)
        {
        }

        virtual void B() override
        {
            // Do operation B.
        }
    };


    void DoSomething(Base& object)
    {
        switch (object.GetType())
        {
        case Base::ObjectType::IsA:
            {
                IA& a = reinterpret_cast<IA&>(object);
                a.A();
            }
            break;
        case Base::ObjectType::IsB:
            {
                IB& b = reinterpret_cast<IB&>(object);
                b.B();
            }
            break;
        default:
            throw std::exception("Expected object to implement IA or IB");
        }
    }
}
